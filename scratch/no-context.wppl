///fold:
var getMarginal = function(erp,key){
  return Enumerate(function(){
    return sample(erp)[key];
  });
};


// functional form relating u to zGold and zBias

var getZGold = function(u,params){
  return Gaussian( {mu:u, sigma:params.goldSigma} ) ;
};

var getZBias = function(u,params){
  var constant = params.biasConstant;
  var sigma = params.biasSigma; 
  return Gaussian( {mu:u+constant, sigma:sigma} );
};

// Priors on U and params
var priorU = function(){return sample(Gaussian({mu:0, sigma:1}))};

var priorParams = function(biasDependsGold){
  if (!biasDependsGold){
    return {
      goldSigma: sample(Gamma({shape:1, scale:1})),
      biasSigma: sample(Gamma({shape:1, scale:1})),
      biasConstant: sample(Gaussian({mu:0, sigma:1}))
    };
  } else {
    var goldSigma = sample(Gamma({shape:1, scale:1}));
    return {
      goldSigma: goldSigma,
      biasSigma: goldSigma + sample(Gamma({shape:1, scale:1})), 
      biasConstant: sample(Gaussian({mu:0, sigma:1}))
    };
  }
};
///

// Actual values U and params

var params = {
  goldSigma: .1, 
  biasConstant: .5,
  biasSigma: .2
};

var getDataPoint = function(u, params){
  return {
    u: u,
    zGold: sample(getZGold(u,params)).toPrecision(3),
    zBias: sample(getZBias(u,params)).toPrecision(3),
  };
};

var generateData = function(numberDataPoints, params){
  return repeat(numberDataPoints, 
                function(){return getDataPoint(priorU(),params);})
};                    
                   
var numberDataPoints = 10;
var data = generateData(numberDataPoints,params);
var trainingData = data.slice(0,5);
var testData = data.slice(5);  // make copy with u removed

print( "u vs. zGold")
viz.scatter( _.map(data,'u'), _.map(data,'zGold') );

print( "u vs. zBias")
viz.scatter( _.map(data,'u'), _.map(data,'zBias') );

print( "zBias vs. zGold")
viz.scatter( _.map(data,'zBias'), _.map(data,'zGold') );


var conditionU = function(){
  var params = priorParams( false );

  map(
    function(dataPoint){
      var u = priorU();
      factor( getZGold(u,params).score( dataPoint.zGold) );
      factor( getZBias(u,params).score( dataPoint.zBias) );
    },
    trainingData);
  
  var testInfer = map(
    function(dataPoint){
      var u = priorU();
      var zGold = sample(getZGold(u,params));
      factor( getZBias(u,params).score( dataPoint.zBias) );
      return {u: u, zGold:zGold, zBias:dataPoint.zBias};
    },
    testData);   
  
  return {
    goldSigma: params.goldSigma,
    biasConstant: params.biasConstant,
    biasSigma: params.biasSigma,
    testInfer: testInfer
    };
};

var out = Infer({method: 'MCMC', samples: 50000}, conditionU);

print('testinfer real and MAP')
print(JSON.stringify(_.map(testData,'u')))
print(JSON.stringify( _.map(out.MAP().val.testInfer,'u')));

var squaredError = function(m1, m2) {
  var x = T.add(m1, T.mul(m2, -1));
  return T.sumreduce(T.mul(x, x));
};


var actualUValues = Vector(_.map(testData,'u'));
var inferUValues = Vector(_.map(out.MAP().val.testInfer,'u'));
var mseU = squaredError(actualUValues, inferUValues) / testData.length;
print( 'mseU:' + JSON.stringify(mseU) );


var paramsNames = ['goldSigma', 'biasSigma', 'biasConstant'];

var compareMAP = function(erp){
  var outMAP = out.MAP().val;
  
  return map( function(paramName){
    return Math.abs(params[paramName] - outMAP[paramName])
  }, paramsNames);  
}
print( compareMAP(out))

map( function(paramName){
  print('variable name: ' + paramName);
  var erp = getMarginal(out, paramName);
   viz.auto(erp);
 }, paramsNames);

null
