// Model 1

var st = JSON.stringify;
var pp = function(a,b,c){
  print( JSON.stringify(a) + ' \n' + JSON.stringify(b) + 
         ' \n' +  JSON.stringify(c) );
};





// Generative model 

var getDatumGivenContext = function(x, params){
  var u = params.u;
  var b = params.b;
  var ux = sample(u(x));
  var bx = sample(b(ux));
  return {x:x, u:ux, b: bx};
};



// Priors on U and B (for inference)

var priorU = function(fixCoefficients){
  var getCoefficient = function(){return sample(Gaussian({mu:0, sigma:2}));}
  
  var degree = 4;
  var coefficients = fixCoefficients ? fixCoefficients : repeat(degree+1, getCoefficient);
  
  var f = function(x){
    var value =  sum( map(function(i){
      return coefficients[i] * Math.pow(x,i)
    }, _.range(degree+1)));
    return Gaussian({mu:value, sigma:.001});
  };
    
  return {
    f: f,
    params:{coefficients: coefficients}
  };
};


var priorB = function(){
  var biasConstant = sample(Gaussian({mu:0, sigma:1}));
  var biasSigma = sample(Gamma({shape:1, scale:1}));
  var f = function(u){
    return Gaussian({mu:u + biasConstant, sigma:biasSigma});
  }
  return {f: f,
          params: {biasConstant:biasConstant, biasSigma:biasSigma}
         };
};


var priorParams = function(fixCoefficients){
  var u = priorU(fixCoefficients);
  var b = priorB();
  return {
    u: u.f,
    b: b.f,
    uParams: u.params,
    bParams: b.params
  };
};


// Generate train and test data
var generateData = function(N, priorX, params, xs){
  var xs = xs ? xs : repeat(N,priorX);
  
  return map(function(x){
    return getDatumGivenContext(x, params);
  }, xs); 
};

var priorX = function(){return sample(Gaussian({mu:0, sigma:1}));};

var params = priorParams([1,-2,-6, 0.5, 1]);

var trainingData = generateData(20, priorX, params);
var testPrior = function(){return sample(Uniform({a:2, b:4}))};
var testData = generateData(20, testPrior, params);

// display function u and b
var displayParams = function(params){
  print('Display true functions u and b on range [-4,4]');
  var xs = repeat(200,function(){return sample(Uniform({a:-4,b:4}))});
  var u = params.u
  var b = params.b
  var uValues =  map(function(x){return sample(u(x))}, xs);
  viz.scatter(xs, uValues);
  var bValues =  map(function(x){return sample(b(x))}, uValues);
  viz.scatter(xs, bValues);
};

displayParams(params);

var displayData = function(trainingData, testData){
  print('Display Training and then Test Data')

  map(function(data){
    var xs = _.map(data,'x');
    var bs = _.map(data,'b');
    viz.scatter(xs,bs)
  }, [trainingData, testData]);
};

displayData(trainingData, testData);


  

// Condition on data

// model with likeihoods: need to adjust how we treat the scores
var model = function(){
  var params = priorParams();
  var u = params.u
  var b = params.b
  
  map( function(datum){
    factor( u(datum.x).score(datum.u) );
    factor( b(datum.u).score(datum.b) );
  }, trainingData);

  // test score
  var totalLikelihood = sum(map( function(datum){
    factor( b(datum.u).score(datum.b) );
    return u(datum.x).score(datum.u);
  }, testData));
  
  return { uParams: params.uParams,
           bParams: params.bParams,
           totalLikelihood: totalLikelihood};
};

 
var erp = Infer({method:'MCMC', samples:10000, verbose:false}, model);

print('true params: ' + JSON.stringify(params) );
var mapCoefficients = Vector( erp.MAP().val.uParams.coefficients );
var trueCoefficients = Vector( params.uParams.coefficients );

var squaredDistance = function(m1, m2) {
  var x = T.add(m1, T.mul(m2, -1));
  return T.sumreduce(T.mul(x, x));
};
var diff = T.add( mapCoefficients, T.mul(trueCoefficients,-1));
var mse = squaredDistance(mapCoefficients, trueCoefficients);

pp('\n\n True vs. map coefficeints MSE:', diff, mse)


// var parameterU = Enumerate(function(){
//   return sample(erp).uParams;
// });

// viz.auto(parameterU)






null;
