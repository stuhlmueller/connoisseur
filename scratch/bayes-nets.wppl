// Model 1


// Generative model 

var getDatumGivenContext = function(x, params){
  var u = params.u;
  var b = params.b;
  var ux = sample(u(x));
  var bx = sample(b(ux));
  return {x:x, u:ux, b: bx};
};



// Priors on U and B (for inference)

var priorU = function(){
  //var a = Vector( repeat( dim, function(){return sample(Gaussian({mu:0, sigma:1}));}) )
  var a = sample(Gaussian({mu:0, sigma:2}));
  return {f: function(x){return Gaussian({mu:a*x, sigma:.001});}, 
          params:{a:a}};
};


var priorB = function(){
  var biasConstant = sample(Gaussian({mu:0, sigma:1}));
  var biasSigma = sample(Gamma({shape:1, scale:1}));
  var f = function(u){
    return Gaussian({mu:u + biasConstant, sigma:biasSigma});
  }
  return {f: f,
          params: {biasConstant:biasConstant, biasSigma:biasSigma}
         };
};


var priorParams = function(){
  var u = priorU();
  var b = priorB();
  return {
    u: u.f,
    b: b.f,
    uParams: u.params,
    bParams: b.params
  };
};


// Generate train and test data
var generateData = function(N, priorX, params){
  var xs = repeat(N,priorX);
  
  return map(function(x){
    return getDatumGivenContext(x, params);
  }, xs); 
};

var priorX = function(){return sample(Gaussian({mu:0, sigma:1}));};

var params = {
  u: function(x){return Gaussian({mu:2*x, sigma:.001})},
  uParams: {a:2},
  b: function(u){return Gaussian({mu:u+1, sigma:0.5})},
  bParams: {biasConstant:1, biasSigma:0.5}
};

var trainingData = generateData(20, priorX, params);
var testData = generateData(20, priorX, params);


// Condition on data

// model with likeihoods: need to adjust how we treat the scores
var model = function(){
  var params = priorParams();
  var u = params.u
  var b = params.b
  
  map( function(datum){
    factor( u(datum.x).score(datum.u) );
    factor( b(datum.u).score(datum.b) );
  }, trainingData);

  // test score
  var totalLikelihood = sum(map( function(datum){
    factor( b(datum.u).score(datum.b) );
    return u(datum.x).score(datum.u);
  }, testData));
  
  return { uParams: params.uParams, 
           bParams: params.bParams,
           totalLikelihood: totalLikelihood};
};

 
var erp = Infer({method:'MCMC', samples:10000, verbose:false}, model);

print('true params: ' + JSON.stringify(params) );
print('\n\n MAP for model' + JSON.stringify(erp.MAP().val) );

var parameterU = Enumerate(function(){
  return sample(erp).uParams;
});

viz.auto(parameterU)




var modelMSE = function(){
  var squaredError = function(x,y){return (x-y)*(x-y);};
  
  var errorOnData = function(params, data) {
    return map(function(datum){
      var predictedDatum = getDatumGivenContext(datum.x, params);    
      var uError = squaredError(predictedDatum.u, datum.u);
      var bError = squaredError(predictedDatum.b, datum.b);
      return {u: uError, 
            b:bError, 
            sum: uError + bError};
    }, data);
  };
  
  var params = priorParams();
 
  var trainError = sum(_.map(errorOnData(params, trainingData), 'sum'));
  factor(-trainError);

  var N = testData.length;
  var testError = (1/N)*sum(_.map(errorOnData(params, testData), 'u'))
 
  return {uParams: params.uParams, 
          bParams: params.bParams,
          testError: testError};
};

var inferModelMSE = function(){
  var erp = Infer({method:'MCMC', samples:10000, verbose:false}, model);
  print('true params: ' + JSON.stringify(params) );
  print('\n\n MAP for model' + JSON.stringify(erp.MAP().val) );
  viz.auto(parameterU)
};

null;
